module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregatePet {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createPet(data: PetCreateInput!): Pet!
  updateManyPets(data: PetUpdateManyMutationInput!, where: PetWhereInput): BatchPayload!
  deleteManyPets(where: PetWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pet {
  birth: DateTime
  death: DateTime
  name: String
  owner: String
  sex: String
  species: String
}

type PetConnection {
  pageInfo: PageInfo!
  edges: [PetEdge]!
  aggregate: AggregatePet!
}

input PetCreateInput {
  birth: DateTime
  death: DateTime
  name: String
  owner: String
  sex: String
  species: String
}

type PetEdge {
  node: Pet!
  cursor: String!
}

enum PetOrderByInput {
  birth_ASC
  birth_DESC
  death_ASC
  death_DESC
  name_ASC
  name_DESC
  owner_ASC
  owner_DESC
  sex_ASC
  sex_DESC
  species_ASC
  species_DESC
}

type PetPreviousValues {
  birth: DateTime
  death: DateTime
  name: String
  owner: String
  sex: String
  species: String
}

type PetSubscriptionPayload {
  mutation: MutationType!
  node: Pet
  updatedFields: [String!]
  previousValues: PetPreviousValues
}

input PetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PetWhereInput
  AND: [PetSubscriptionWhereInput!]
  OR: [PetSubscriptionWhereInput!]
  NOT: [PetSubscriptionWhereInput!]
}

input PetUpdateManyMutationInput {
  birth: DateTime
  death: DateTime
  name: String
  owner: String
  sex: String
  species: String
}

input PetWhereInput {
  birth: DateTime
  birth_not: DateTime
  birth_in: [DateTime!]
  birth_not_in: [DateTime!]
  birth_lt: DateTime
  birth_lte: DateTime
  birth_gt: DateTime
  birth_gte: DateTime
  death: DateTime
  death_not: DateTime
  death_in: [DateTime!]
  death_not_in: [DateTime!]
  death_lt: DateTime
  death_lte: DateTime
  death_gt: DateTime
  death_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  owner: String
  owner_not: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_gt: String
  owner_gte: String
  owner_contains: String
  owner_not_contains: String
  owner_starts_with: String
  owner_not_starts_with: String
  owner_ends_with: String
  owner_not_ends_with: String
  sex: String
  sex_not: String
  sex_in: [String!]
  sex_not_in: [String!]
  sex_lt: String
  sex_lte: String
  sex_gt: String
  sex_gte: String
  sex_contains: String
  sex_not_contains: String
  sex_starts_with: String
  sex_not_starts_with: String
  sex_ends_with: String
  sex_not_ends_with: String
  species: String
  species_not: String
  species_in: [String!]
  species_not_in: [String!]
  species_lt: String
  species_lte: String
  species_gt: String
  species_gte: String
  species_contains: String
  species_not_contains: String
  species_starts_with: String
  species_not_starts_with: String
  species_ends_with: String
  species_not_ends_with: String
  AND: [PetWhereInput!]
  OR: [PetWhereInput!]
  NOT: [PetWhereInput!]
}

type Query {
  pets(where: PetWhereInput, orderBy: PetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pet]!
  petsConnection(where: PetWhereInput, orderBy: PetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PetConnection!
  node(id: ID!): Node
}

type Subscription {
  pet(where: PetSubscriptionWhereInput): PetSubscriptionPayload
}
`
      }
    